;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;; SPECIFIC VPC-DA CODE ;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;; CODE NEEDED BECAUSE WHIZZML IS OUTDATED ;;;;;;;
;;;;;;;;;;;;;;;; This wont work in production ;;;;;;;;;;;;;;;;;

;; Maps the field IDs for two field structures by an attribute (usually
;; **name** or **column number**
(define (bigml.fields-lib.map-field-ids fields new-fields attr)
  (when (or (not (every? (lambda (x) (contains? x attr))
                         (values fields)))
            (not (every? (lambda (x) (contains? x attr))
                              (values new-fields))))
    (raise (str "Failed to find the attribute " attr
                " in the field structures")))
  (let (attr->id (lambda (fs)
                   (let (att-vals (map (lambda (f) (str (f attr)))
                                       (values fs)))
                     (make-map att-vals (keys fs))))
        attrs (attr->id fields) ;; map attr-value => id
        attrs2 (attr->id new-fields))
   (iterate (r {} att-val (keys attrs))
     (assoc r (attrs att-val) (attrs2 att-val false)))))
;; Maps the field IDs for two field structures according to their
;; field names
(define (bigml.fields-lib.map-fields-by-name fields new-fields)
  (bigml.fields-lib.map-field-ids fields new-fields "name"))
;; Maps the field IDs for two field structures according to their
;; column numbers
(define (bigml.fields-lib.map-fields-by-column fields new-fields)
  (bigml.fields-lib.map-field-ids fields new-fields "column_number"))
;; Applies the IDs changes to an existing structure describing
;; fields properties.
;;
;; ids-map: (map) Map from field IDs to field IDs as generated by
;;          bigml.fields-lib.map-field-ids
;; struc: (map) Fields properties structure. E.g.
;;                {"000000" {"optype" "categorical"}}}
(define (bigml.fields-lib.apply-fields-map ids-map struc)
  (iterate (acc {} id (keys ids-map))
    (if (and (ids-map id) (contains? struc id))
        (assoc acc (ids-map id) (struc id))
        acc)))
;; Gets the fields map structure by using the new IDs
;; field-changes is a fields structure needed to change fields attributes
(define (bigml.fields-lib.adapt-field-changes parent-fields field-changes)
  (iterate (acc {} key (keys field-changes))
    (let (field (find-field parent-fields key) ;; {"field_name" {"optype"...
          field-id (when (map? field)
                         (field "id" false)))
      (if (string? field-id)
          (assoc acc field-id (field-changes key))
          acc))))
;; changes all references from the original IDs to the ones in resource-id
;; mapping them by name.  res-id can be either a single resource id
;; or a list thereof.
(define (bigml.fields.to-ids config-map res-id)
  (let (res-list (if (list? res-id)
                     res-id
                     (list res-id)))
    (iterate (config-map config-map res-id res-list)
      (let (fields (config-map "fields" false)
            fields-with-name (if (or (= "source" (resource-type res-id))
                                     (not fields))
                                 fields
                                 (iterate (acc fields f-id (keys fields))
                                   (if (contains? (fields f-id) "name")
                                       acc
                                       (assoc-in acc [f-id "name"] f-id))))
            new-fields (reduce (lambda (fs id)
                                 (merge (resource-fields id) fs))
                               {}
                               (if (list? res-id) res-id [res-id]))
            new-config-fields (when fields
                                (let (n (bigml.fields-lib.map-fields-by-name fields-with-name
                                                                         new-fields))
                                  (bigml.fields-lib.apply-fields-map n fields)))
            new-config-fields (if (and fields
                                       (empty? new-config-fields))
                                  (bigml.fields-lib.adapt-field-changes
                                    new-fields
                                    fields)
                                  new-config-fields)
            objective-id (let (fname (config-map ["objective_field" "name"] false))
                           (when fname
                             (let (f (find-field new-fields fname))
                               (when f (f "id" false)))))
            config-map (if objective-id
                           (assoc config-map "objective_field" {"id" objective-id})
                           config-map))
        (if fields
            (assoc config-map "fields" new-config-fields)
            config-map)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define reuse-resources (not (= (resource-type train-source) "source")))

(define (dataset-from-source src-id obj)
  (let (obj-id ((find-field (resource-fields src-id) obj) "id"))
    (create-dataset src-id {"objective_field" {"id" obj-id}})))

(define (get-input name)
  (let (get-value (lambda(input) (if reuse-resources
                                   (input-from-exec automl-execution name)
                                   input)))
    (cond (= name "configuration-params") (get-value configuration-params)
          (= name "train-source") (get-value train-source))))

(define [train-dataset validation-dataset]
  (create-random-dataset-split
   (dataset-from-source (get-input "train-source") objective-name)
   0.8
   {"name" "Train dataset"}
   {"name" "Validation dataset"}))

(define test-dataset
  (when (= (resource-type test-source) "source")
    (dataset-from-source test-source objective-name)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;; GENERAL AUTOML CODE ;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Whether we should reuse resources from a given execution
;; (define reuse-resources (not (= (resource-type train-dataset) "dataset")))
;; Get the value of an input parameter from the current
;; execution, or from a previous execution if it is given
;; Input parameters from automl-execution overwrite the ones
;; given by the user in the current execution
;(define (get-input name)
;  (let (get-value (lambda(input) (if reuse-resources
;                                   (input-from-exec automl-execution name)
;                                   input)))
;    (cond (= name "configuration-params") (get-value configuration-params)
;          (= name "train-dataset") (get-value train-dataset))))

;; Execution configuration parameters
(define config (get-input "configuration-params"))

(when (not (= config configuration-params))
  (log-warn "WARNING: Configuration params from the automl-execution "
            " overwrite the given params")
  (log-info "Configuration used: ")
  (log-info config))

(log-featured "Initial checks")
(log-info "Checking execution input datasets")
(check-inputs train-dataset validation-dataset test-dataset automl-execution)
(log-info "Checking input dataset fields")
;; Commented for specific VPC version
;(check-datasets-fields (get-input "train-dataset")
;                       validation-dataset
;                       test-dataset)
(log-info "Check configuration params")
(check-configuration-params config)
(log-info "Checking excluded-models")
(check-excluded-models (config "excluded-models"))
(log-info "More configuration parameters checks")
(check-params (config "pca-variance-threshold")
              (config "max-rules"))

;; Retrieve all non-preferred fields from all the datasets
;; General version (this one is specific for VPC-DA) uses
;; (get-input "train-dataset")
(define non-preferred-fields
  (remove-duplicates
   (flatten
    (map (lambda(ds) (field-names-from-ids (non-preferred ds) ds))
         [train-dataset validation-dataset test-dataset]))))

(log-info "These fields will be set as non-preferred:")
(log-info non-preferred-fields)


(log-featured "Feature generation")
(log-info "Obtaining unsupervised models")
;; Returns a list of unsupervised-models from a dataset
(define (create-unsupervised-models dataset excluded excluded-models)
  (let (_ (set-non-preferred dataset non-preferred-fields)
        params {"excluded_fields" (field-ids-from-names excluded dataset)}
        objective-id (dataset-get-objective-id dataset)
        lev-params (merge params {"rhs_predicate" [{"field" objective-id}]
                                  "search_strategy" "leverage"})
        lift-params (merge params {"rhs_predicate" [{"field" objective-id}]
                                   "search_strategy" "lift"})
        all-models
        (map (lambda (type params*)
               (when (create-unsupervised? type excluded-models)
                 (create-unsupervised type dataset params*)))
        ["association" "association" "cluster" "anomaly" "pca" "topicmodel"]
        [lev-params lift-params params params params params]))
    (remove-false all-models)))

;; Returns a list of unsupervised model from an execution output
(define (get-unsupervised-models automl-exec excluded-models)
  (filter (lambda(m)(create-unsupervised? (resource-type m) excluded-models))
          (output-from-exec automl-exec "unsupervised-models")))

;; List that contains all the created unsupervised models
(define unsupervised-models
  (let (exc-fields (config "excluded-fields")
        exc-models (config "excluded-models"))
    (if reuse-resources
      (get-unsupervised-models automl-execution exc-models)
      (create-unsupervised-models train-dataset exc-fields exc-models))))

(log-info "Generating new features from unsupervised models")
(define (feature-generation dataset-id
                            model-list
                            excluded
                            pca-threshold
                            max-rules)
  (let (excluded (remove-false (field-ids-from-names excluded dataset-id))
        objective-id (dataset-get-objective-id dataset-id)
        name (resource-name dataset-id)
        feat-gen (lambda (model-type batch-type params)
                   (unsupervised-feature-gen dataset-id
                                             model-list
                                             name
                                             model-type
                                             batch-type
                                             params))
        cluster-fields (feat-gen "cluster" "batchcentroid" {})
        anomaly-fields (feat-gen "anomaly" "batchanomalyscore" {})
        topic-fields (feat-gen "topicmodel" "batchtopicdistribution" {})
        pca-params {"variance_threshold" pca-threshold}
        pca-fields (feat-gen "pca" "batchprojection" pca-params)
        dataset-assoc (assoc-feature-gen dataset-id
                                         model-list
                                         name
                                         excluded
                                         max-rules)
        all-fields [cluster-fields anomaly-fields topic-fields pca-fields]
        all-ds (cons dataset-assoc (map batch-output-ds all-fields)))
    (feature-generation-dataset all-ds name objective-id non-preferred-fields)))

(define extended-datasets
  (let (exc-fields (config "excluded-fields")
        pca-threshold (config "pca-variance-threshold")
        max-rules (floor (config "max-rules")))
    (map (lambda(dataset)
           (when (= (resource-type dataset) "dataset")
             (log-info " - Extending dataset: " (resource-name dataset))
             (feature-generation dataset
                                 unsupervised-models
                                 exc-fields
                                 pca-threshold
                                 max-rules)))
         [train-dataset validation-dataset test-dataset])))


(log-featured "Feature Selection")
(log-info "Obtaining the most important features")
;; Obtains the list of important fields from
;; a previous execution
(define (retrieve-important-fields exec)
  (when (= (resource-type exec) "execution")
    (output-from-exec exec "selected-fields")))

;; Obtains the most important fields from a dataset
;; using recursive feature elimination
(define (compute-important-fields train test)
  (let (bal-obj (config "balance-objective")
        rfe-output (recursive-feature-elimination train 1 "" test "" bal-obj)
        evaluations (rfe-output "evaluations" {})
        num-features (rfe-best-num-features evaluations))
    (rfe-output-fields train evaluations num-features)))

;; Obtains the most important fields (a list with their names)
;; from a train and an optional test dataset
(define selected-fields
  (if reuse-resources
    (retrieve-important-fields automl-execution)
    (let ([train valid test] extended-datasets
          [train* test*] (if (= "dataset" (resource-type valid))
                           [train valid]
                           (wait* (create-random-dataset-split train 0.8))))
      (compute-important-fields train* test*))))

(log-info "Filtering the datasets")
;; Creates the filtered datasets from the extended datasets,
;; filtering out all the fields not present in selected-fields list
(define filtered-datasets
  (map (lambda (ds) (when (= "dataset" (resource-type ds))
                      (let (name (str (resource-name ds) " | filtered")
                            fields (field-ids-from-names selected-fields ds))
                        (create-dataset {"name" name
                                         "origin_dataset" ds
                                         "input_fields" fields}))))
       extended-datasets))

(log-featured "Model Selection")
;; Creates the final fusion model with the top 5 models
;; from an optiml generated with the filtered datasets
(define output-fusion
  (let ([train valid _] filtered-datasets)
    (if reuse-resources
      (retrieve-fusion automl-execution)
      (fusion-from-optiml (create-optiml-model train valid) 3))))


(log-featured "Final dataset and evaluation")
(log-info "Creating output dataset")
;; Creates the final output dataset with the
;; original fields and the predictions from
;; the fusion model
(define output-dataset
  (when (= (resource-type test-dataset) "dataset")
    (let ([train valid test] filtered-datasets)
      (prediction-from-fusion output-fusion test))))

(log-info "Creating output evaluation")
;; Creates the final evaluation from the validation
;; dataset and the fusion
(define output-evaluation
  (when (= (resource-type validation-dataset) "dataset")
    (let ([_ valid _] filtered-datasets)
      (create-evaluation output-fusion valid))))
